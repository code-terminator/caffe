
# coding: utf-8

# In[7]:

import os
import sys
sys.path.append("/home/bugfree/Workspace/caffe/python")
import caffe
from google.protobuf.text_format import PrintMessage, Merge


# In[8]:

def _train_net (solver_prototxt, data_provider, output_dir, maxiter,\
               resume_file=None, weight_file=None, log_to_file=False):
    '''
    This is private helper function to train a deep net
    INPUT:
        solver_prototxt: the file name and pull path of the solver prototxt
        data_provider: should be in the form of [train_data_provider, test_data_provider]
    NOTE:
        This fucntion assumes the first layer is a data layer
    '''
    # get the solver from the prototxt
    solver = caffe.get_solver(solver_prototxt)
    # assuming the data layer is located at the very very bottom
    # set the data for training
    solver.net.layers[0].set_data(data_provider[0])
    # set the data for testing if necessary
    if len(solver.test_nets) > 0:
        solver.test_nets[0].layers[0].set_data(data_provider[1])
    if resume_file is not None:
        # if a resume file exists, we want to resume the process
        solver.solve(resume_file)
    elif weight_file is not None:
        # reload the weight
        solver.net.copy_from(weight_file)
        solver.solve()
    else:
        # train from the begining
        solver.solve()

# In[9]:

def train_net (solver, net, data_provider, output_dir, maxiter,\
              resume_file=None, weight_file=None, log_to_file=False):
    '''
    This function is used to train a deep net by first construct two files:
    solver_proto and net_proto, respectively. With other parameters/options
    we can 1) train the net from begining, 2) resume a training, 3) reload
    the weight for the net
    Inputs:
        solver: the solver generated by the caffe funtion: caffe.proto.caffe_pb2.SolverParameter.
        net: the connections of the deep net, which is generated by the caffe funtion:
            caffe.params.to_proto
        data_provider: should be in the form of [train_data_provider, test_data_provider]
        output_dir: the output directory for saving the prototxt and log
        maxiter: the maximum iteration
        resume_file: a file indicates where we can resume from
        weight_file: a file for weights reloading
        log_to_file: a binary value to indicate whether you want to write the log to a file
    Notes:
        This function always assume using GPU as the tool for computing
    '''
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    print "Training job at location: %s" %output_dir
    # set the log directory if necessary
    if log_to_file:
        caffe.set_logging_dest(output_dir + "/LOG")
    # always using GPU for computing
    caffe.set_mode_gpu()
    # convert the network connection to prototxt (explictly write it in file)
    PrintMessage(net, open(output_dir + "/net.prototxt","w"))
    # put the file name into solver
    solver.net = output_dir + "/net.prototxt"
    # convert the solver to prototxt (explictly write it in file)
    PrintMessage(solver, open(output_dir + "/solver.prototxt","w"))
    # start the job
    _train_net(output_dir + "/solver.prototxt", data_provider, output_dir, maxiter,\
                   resume_file, weight_file)

# In[3]:

if __name__ == "__main__":
    pass
